File Documentation
==================

This page will go through each file with a docstring and display them here in a structured order. This page is a good reference to keep open while working as a quick glance to see what each file does.


* `.clang-format`: This is the file used by the clang-format tool, which makes sure that the  code base follows a consistent coding style. For those familiar, it is  similar to python’s flake8. Inside the file we specify how we want our  codebase to look. For detailed explanation of each option, the reader is  referred to the official documentation which also contains a lot of examples  for each option: https://clang.llvm.org/docs/ClangFormatStyleOptions.html.  Rather than running clang-format directly, we make use of 2 python scripts:  scripts/cmake_checks/check_clang_format.py and  scripts/standalone/apply_clang_format.py.
* `.clang-tidy`: This is the file used by the clang-tidy tool, which performs static analysis. Inside the file we specify which files to ignore when going through the codebase. Rather than using clang-tidy directly, we make use of a python script: scripts/cmake_checks/clang_tidy.py. Note: clang-tidy may fail the first time we run scripts/build/build_all.sh since the compilation database would not have been built by then. So when we run it afterwards it will be successful.
* `.clangd`: This file indicates to the clang compiler (which is used for linting) certain options. This includes for example ignoring certain flags which are specific to the nvcc compiler
* `.gitignore`: 
* `.ycm_extra_conf.py`: This file is used by the YouCompleteMe language server to get the build from the compilation_database_folder (./build in our case)
* `CMakeLists.txt`: This is the root cmake file where the sources lie Different CMake versions have more features.
* **.github**:

  * **workflows**:

    * `publish-documentation.yml`: This is the file responsible for building the documentation and tests on github using github-actions and then publishing both the documentation and test results + code coverage as a github page. Within the file, each step has a name which describes its purpose.

* **cmake**:

  * `CCache.cmake`: Enables CCache, which prevents rebuilding of files which are already built
  * `CompilerWarnings.cmake`: Obtained from: https://github.com/lefticus/cpp_starter_project/blob/master/cmake/CompilerWarnings.cmake This file creates a function to enable compiler warnings for both MSVC as well as other compilers
  * `ExportCompileCommands.cmake`: This results in a compilation database to be exported upon building. This compilation database is a json file containing all the commands used. It can be used by some language servers to retrace the commands issued by cmake to be able to do proper file linking and detect proper header includes, etc
  * `Options.cmake`: This enables or disables several CMake options
  * `PreventBuildingInCmakeDirectory.cmake`: This file ensures that CMake does not run in a folder where there is an existing CMakeLists.txt, as this is usually not desired. It is better to build in a separate directory as CMake generates a lot of 'garbage' files for caching
  * `Profiling.cmake`: Adds the flags -pg to gcc so we can profile with gprof

* **docs**:

  * `.gitignore`: Ignore everything except itself and index.html

* **documentation**: Any files related to documentation contents will be kept here. Documentation is generated by both doxygen and Sphinx

  * `.gitignore`: Ignores unnecessary files and files which are generated on the fly when building
  * `CMakeLists.txt`: Looks for Doxygen and fails if it cannot find it. If it finds it, it will replace any text within the specified files (usually these files will end with the .in extension) which is surrounded by @ by the parameters provided by cmake. For example, if we look at the first line of documentation/index.rst, you will notice that part of the title is surrounded by @. This part will be replaced by the same value as it is within cmake. The output file is the same file but without the .in extension, so that the original file is unmodified. So if the input is a.txt.in, the output will be a.txt. Look at the configure_file cmake command here: https://cmake.org/cmake/help/latest/command/configure_file.html. This CMakeLists.txt is not to be used directly, but rather through the scripts/build/build_docs.sh script.
  * `Doxyfile.in`: This file describes the settings to be used by the documentation system doxygen (www.doxygen.org) for a project. Change the settings here as you see fit, however make sure to keep GENERATE_XML to YES, because this output is used by Sphinx’s breathe extension to generate our documentation.
  * `conf.py.in`: Configuration file for the Sphinx documentation builder. This is where we specify the theme, the extensions we wish to use and other options for our documentation
  * `make.bat`: This is the Windows equivalent of the Makefile for the documentation. It is usually unused.
  * **RST**:

    * `.gitignore`: Ignore everything in the folder except for itself and the .doc_string

  * **static**:

    * `.gitignore`: Ignore everything in the folder except for itself

* **hooks**:

  * `ascii_and_whitespace.sh`: The default git pre-commit hook to remove trailing whitespaces. It also makes sure that all files are ascii
  * `pre-commit`: Used as a pre-commit check for git. Adding or removing commands is extremely easy by changing the 'hook_commands' list. If any of the commands fail, then the hook will fail.

* **scripts**: This folder contains scripts written in multiple languages which are used to combine multiple commands into a single file. It is advised to only build using these scripts rather than using the individual Tools directly.

  * **build**: Scripts used to build executables and documentation. Within this script, cmake configuration options are set. Change these if you wish to set different options.

    * `all.sh`: Build the main executable, tests as well as documentation in debug mode. If any argument at all is passed to this script, it will skip the cmake step and just execute the build step only
    * `compilation_commands.sh`: Generate the compilation commands database (in build/compile_commands.json)
    * `debug.sh`: Build the main executable in debug mode. If any argument at all is passed to this script, it will skip the cmake step and just execute the build step only
    * `docs.sh`: Build the main executable in debug mode. If any argument at all is passed to this script, it will skip the cmake step and just execute the build step only
    * `release.sh`: Build the main executable. If any argument at all is passed to this script, it will skip the cmake step and just execute the build step only.
    * `tests.sh`: Build the main test executable. If any argument at all is passed to this script, it will skip the cmake step and just execute the build step only

  * **standalone**: Scripts which usualy alter the repository in some manner, either by modifying files or by adding new files

    * `apply_clang_format.py`: Applies the changes proposed by clang format. Warning: This actually changes the source code. While it would not change the contents, make sure that you agree with the changes (you can check what changes will be applied if you run ./scripts/static_analysers/clang_format.py)
    * `apply_iwyu.py`: This file checks for incorrect includes in a file, folder or the entire repository and applies include-what-you-use as well as clang-format to them  THIS IS NOT RECOMMENDED TO USE YET (at least not until iwyu gets out of alpha and is ready for production)
    * `generate_file_documentation.py`: Goes through the specified files in the repository, reads the first comment, and generates a documentation page file tree with the directory structure and the comment next to the file. This makes it easier to generate documentation where the user can see all the file descriptions in one documentation page
    * `test.sh`: Run the tests as well as generate code coverage. Also generates html so that code coverage can easily be seen in the docs.
    * `unix_line_endings.sh`: run twice as sometimes once is not enough Only run on tracked files

  * **static_analysers**:

    * `clang_format.py`: clang-format is a bit difficult to work with on its own. Its output is not very easy to read. Hence, here we have created a script to make it easier to work with. It creates temporary files so that we see the difference between each file individually, and then we format them as we see fit in stdout, to be easier for the eyes and to see which file is being analysed at the time  This script is executed automatically by cmake when building
    * `clang_tidy.py`: clang-tidy needs the files input manually. However, we do not want to put test files in there, as these trigger a chain reaction to add the googltest imported header files as well. Hence we simply glob for all the other .h and .cpp files and put them through the tool  This script is executed automatically by cmake when building
    * | `headers.py`: 
       Checks that the header files start with:
      |
      | #ifndef FILE_NAME_CAPITALIZED_<EXTENSION>
      | #define FILE_NAME_CAPITALIZED_<EXTENSION>
      |
      | /**
      |  * @file FileName.<extension>
      |  * @brief <description goes here and on next line>
      |
      | and ends with:
      |
      | #endif
      |
      | The term FILE_NAME_CAPITALIZED_<EXTENSION> would be replaced by the filename. So if we have a file called MyClass.h, it would be MY_CLASS_H The steps are:
      |     * Remove the .h
      |     * Convert from camel case to snake case
      |     * capitalise everything
      |     * add a _H at the end
      |
      | If the file is a cuh file, it is the same as above but it will have _CUH at the end
      |
      | The script also checks that python files start with:
      |
      | #!/usr/bin/python3
      | <new line here>
      | <3 " here, ie a docstring>
      |
      | And bash files should start with the following:
      |
      | #!/usr/bin/bash
      | <new line here>
      | # some comment

* **src**:

  * `BuildCommon.cmake`: Builds items which are commonly used between the main program and the tests. Usually these are classes, files and options which are used by the main program but are also tested individually
  * `BuildMain.cmake`: Builds the main program, linking all the files and header files together
  * `BuildTests.cmake`: Builds the testing program. We use googletest as a testing framework
  * `CMakeLists.txt`: Builds the main as well as testing programs
  * **Functions**:

    * `Functions.h`: Contains some functions

